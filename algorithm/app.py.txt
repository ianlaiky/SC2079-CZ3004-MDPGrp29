from typing import List
from abc import ABC, abstractmethod

import pygame

import settings
from entities.assets import colors
from entities.grid.grid import Grid
from entities.grid.obstacle import Obstacle
from entities.robot.robot import Robot
from entities.assets.direction import Direction

class AlgoApp(ABC):
    def __init__(self, obstacles: List[Obstacle]):
        self.obstacles = obstacles
        self.grid = Grid(obstacles)
        self.robot = Robot(self.grid)
        self.index = 0
        self.direction = Direction.LEFT

    @abstractmethod
    def init(self):
        pass

    @abstractmethod
    def execute(self):
        pass


class AlgoSimulator(AlgoApp):
    """
    Run the algorithm using a GUI simulator.
    """
    def __init__(self, obstacles: List[Obstacle]):
        super().__init__(obstacles)

        self.running = False
        self.size = self.width, self.height = settings.WINDOW_SIZE
        self.screen = self.clock = None

    def init(self):
        """
        Set initial values for the app.
        """
        pygame.init()
        self.running = True
        
        self.screen = pygame.display.set_mode(self.size, pygame.HWSURFACE | pygame.DOUBLEBUF |pygame.SCALED)
        self.clock = pygame.time.Clock()
        self.execute()
       

    def settle_events(self):
        """
        Process Pygame events.
        """
        for event in pygame.event.get():
            # On quit, stop the game loop. This will stop the app.
            if event.type == pygame.QUIT:
                self.running = False
            
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if (event.button == 1):                
                    pos = pygame.mouse.get_pos()
                    x = pos[0] // settings.GRID_CELL_SIZE * 10 + 5
                    y = abs(pos[1] // settings.GRID_CELL_SIZE - 19) * 10 + 5
                    print("Left Click ", pos, "Grid coordinates: ", x, y)

                    

                    if len(self.obstacles) > 0 and x == self.obstacles[len(self.obstacles)-1][0] and y == self.obstacles[len(self.obstacles)-1][1]:
                        print("Same coordinates chosen, please choose other coordinates")
                        continue
                    elif len(self.obstacles) > 8:
                        print("ERROR! Maximum number of obstacles is 8")
                        continue

                    obstacle = [x,y,self.direction.value,self.index]
                    self.index += 1
                    self.obstacles.append(obstacle)
                    
                    print(obstacle)
                    
                    obs = self.parse_obstacle_data(self.obstacles)
                    self.grid = Grid(obs)
                    
                    print("Length: "+str(len(self.obstacles)))
                    
                elif(event.button == 3):
                    pos = pygame.mouse.get_pos()
                    x = pos[0] // settings.GRID_CELL_SIZE * 10 + 5
                    y = abs(pos[1] // settings.GRID_CELL_SIZE - 19) * 10 + 5
                    print("Right Click ", pos, "Grid coordinates: ", x, y)
                    
                    ob = [x,y,self.direction.value,self.index]
                    
                    print("Length: " + str(len(self.obstacles)))
                    
                    # Finding the XY coords in the list
                    
                    for lst in self.obstacles:
                        if x in lst:
                            if y in lst:
                                self.obstacles.remove(lst)
                                self.index -= 1
                                print(lst, "REMOVED!")
                            
                    obs = self.parse_obstacle_data(self.obstacles)
                    self.grid = Grid(obs)
                    
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_DOWN:
                    self.direction = Direction.BOTTOM
                    print(self.direction)
                elif event.key == pygame.K_UP:
                    self.direction = Direction.TOP
                    print(self.direction)
                elif event.key == pygame.K_LEFT:
                    self.direction = Direction.LEFT
                    print(self.direction)
                elif event.key == pygame.K_RIGHT:
                    self.direction = Direction.RIGHT
                    print(self.direction)
                elif event.key == pygame.K_SPACE:
                    # Inform user that it is finding path...
                    print("Calculating path...")
                    self.robot = Robot(self.grid)
                    # Calculate the path.
                    self.robot.brain.plan_path()
                    print("Simulating path...")
                    #pygame.display.set_caption("Simulating path!")  # Update the caption once done.
                elif event.key == pygame.K_ESCAPE: #Reset Button
                    self.obstacles = []
                    self.grid = Grid(self.obstacles)
                    self.robot = Robot(self.grid)
                    self.index = 0
                    self.direction = Direction.LEFT
          
            


    def do_updates(self):
        self.robot.update()

    def render(self):
        """
        Render the screen.
        """
        self.screen.fill(colors.WHITE, None)

        self.grid.draw(self.screen)
        self.robot.draw(self.screen)

        # Really render now.
        pygame.display.flip()

    def execute(self):
        """
        Initialise the app and start the game loop.
        """
        while self.running:
            # Check for Pygame events.
            self.settle_events()
            # Do required updates.
            self.do_updates()

            # Render the new frame.
            self.render()

            self.clock.tick(settings.FRAMES)

    def parse_obstacle_data(self,data):
        obs = []
        for obstacle_params in data:
            obs.append(Obstacle(obstacle_params[0],
                                obstacle_params[1],
                                Direction(obstacle_params[2]),
                                obstacle_params[3]))
        # [[x, y, orient, index], [x, y, orient, index]]
        return obs


class AlgoMinimal(AlgoApp):
    """
    Minimal app to just calculate a path and then send the commands over.
    """
    def __init__(self, obstacles):
        # We run it as a server.
        super().__init__(obstacles)

    def init(self):
        pass

    def execute(self):
        # Calculate path
        print("Calculating path...")
        self.robot.brain.plan_path()
        print("Done!")
